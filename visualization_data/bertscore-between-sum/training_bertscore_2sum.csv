,paper_id,summary,summary,summary,summary,summary,summary,summary,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,precision,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,recall,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure,fmeasure
,,0,1,2,3,4,5,6,0-1,0-2,0-3,0-4,0-5,0-6,1-2,1-3,1-4,1-5,1-6,2-3,2-4,2-5,2-6,3-4,3-5,3-6,4-5,4-6,5-6,0-1,0-2,0-3,0-4,0-5,0-6,1-2,1-3,1-4,1-5,1-6,2-3,2-4,2-5,2-6,3-4,3-5,3-6,4-5,4-6,5-6,0-1,0-2,0-3,0-4,0-5,0-6,1-2,1-3,1-4,1-5,1-6,2-3,2-4,2-5,2-6,3-4,3-5,3-6,4-5,4-6,5-6
0,SP:2cf4a3964537ff5dd1f7b600ab567b4d0b3cc03e,"This work reports the problem of image classification datasets (CIFAR-10 and ImageNet) which contains statistical patterns present in both training and tests that can be leveraged by neural networks to achieve high accuracy, but would not be discerned as salient features by humans. Using Sufficient Input Subsets (SIS), they show that retaining the smallest SIS to keep a confidence of 99% leads to spare sets of about 5% of the original pixels and that these subsets of pixels are not salient features for humans. Most importantly they show that training NNs on these SIS from a previously trained network achieves similar results.","The paper evaluates pathologies of modern neural networks on CIFAR-10 and ImageNet. Specifically, the authors show that these networks exhibit *overinterpretation*, which is a phenomenon where a model can use sparse subsets of an image which are semantically meaningless to humans in order to confidently and accurately classify the image. The authors utilize the Sufficient Input Subsets (SIS) algorithm from the interpretability literature to identify these subsets, but they also propose modifications to this algorithm which allow it to scale to ImageNet. Surprisingly, the authors find that models evaluated on a small subset of SIS pixels from each image (5% on CIFAR-10 and 10% on ImageNet) exhibit only a small drop in accuracy. The authors explore two techniques for mitigating overinterpretation: ensembling and input dropout.","The paper identifies sparse sets of pixels which can be used with deep neural nets to classify images with high confidence. The authors demonstrate results with CIFAR-10, an augmentation corrupted version of it and with ImageNet. They show a number of experiments to obtain insights in why these spurious subsets are classified with high confidence.  For example, they show that the sparse subsets can be used to train a different model to predict well on CIFAR-10 and on Imagenet. Furthermore they show that the SIS sizes are larger on correctly classified images compared to misclassified images, which implies that the sets are indeed used to properly predict on images.","The paper presents an interesting finding that CNNs overinterpret a few non-meaningful pixels in the image to make accurate predictions. The authors use SIS and extend it to Batched Gradient SIS to discover the limited number of pixels such CNNs rely on. The authors conduct extensive experiments on two major image datasets to verify the finding. Besides, ensembling and input dropout are explored to mitigate the overinterpretation problem.","Authors define ""overinterpretation"" as an undesired behavior in deep neural networks where the networks find strong class evidence in semantically unrelated image regions. The behaviour is quantified by identifying the minimal number of pixels sufficient to predict a given class in an input image while masking all the other features/pixels. In this regard, protocols are proposed to evaluate overinterpretation and the models trained on CIFAR and ImageNet are shown to suffer from this problem. ","This paper proposes ""overinterpretation"" which describes the phenomenon that CNNs could achieve high test accuracy while replying on features that lack semantic meaning. To demonstrate overinterpretation on CIFAR-10 and ImageNet, the authors use Batched Gradient SIS to select a small subset of pixels for each image and trained CNNs on the modified images. While humans can not make accurate predictions on those modified images, CNNs can still achieve high test accuracy. Lastly, the authors propose to use ensembling and input dropout to address overinterpretation. ","The work utilizes the SIS (a local feature-importance method) to empirically prove that on existing benchmark datasets, the trained convnets are capable of making decisions based on a very small subset of pixels that are meaningless to the human observer but are nonetheless strong signals. Interestingly, unlike common belief, the same phenomenon is observed in adversarially trained models. The main problem with the work is the discrepancy between claims and results. ",0.23300970873786409,0.21359223300970873,0.10679611650485436,0.11650485436893204,0.1650485436893204,0.11650485436893204,0.1968503937007874,0.1889763779527559,0.14960629921259844,0.2125984251968504,0.11023622047244094,0.14414414414414414,0.13513513513513514,0.16216216216216217,0.10810810810810811,0.2318840579710145,0.34782608695652173,0.17391304347826086,0.16,0.14666666666666667,0.15294117647058825,0.1889763779527559,0.1981981981981982,0.15942028985507245,0.16,0.2,0.16666666666666666,0.22522522522522523,0.34782608695652173,0.25333333333333335,0.3176470588235294,0.19444444444444445,0.2318840579710145,0.2,0.21176470588235294,0.16666666666666666,0.21333333333333335,0.2823529411764706,0.16666666666666666,0.1411764705882353,0.1527777777777778,0.18055555555555555,0.20869565217391306,0.205607476635514,0.12790697674418605,0.13483146067415733,0.18085106382978725,0.13714285714285712,0.21008403361344538,0.2448979591836735,0.18811881188118815,0.25471698113207547,0.1407035175879397,0.17777777777777778,0.16129032258064516,0.18367346938775508,0.13114754098360656,0.22222222222222224,0.3116883116883117,0.1702127659574468,0.15000000000000002,0.14965986394557826,0.16560509554140126
1,SP:b622788bec805621c2abf11ffa25c0d55e50f4d3,"The paper performs a detailed hyperparameter study of stochastic optimizers specifically designed for large-batch training (LARS and LAMB). With appropriate hyperparameter tuning, simpler optimizers such as Nesterov SGD and Adam match and sometimes outperform those specialized optimizers on ResNet-50 and BERT. The authors attribute the relative success of large-batch methods to minute undocumented aspects in their implementations, such as regularization and scaling on certain operators, which can be back-ported to the other optimizers, and advocate for more relaxed definitions (e.g. number of steps) for benchmarks such as MLPerf Training.","This paper was previously rejected by NeurIPS and ICML. I was one of the NeurIPS reviewers for this paper. Although the authors made some changes, after carefully reading this paper, I found it did not change too much for key techniques and key contributions. So I decided to use my previous NeurIPS review.  ###############################################################################################################  The authors used a huge amount of computing resources to tune hyperparameters of Adam/SGD and claimed that they can match the performance of LARS/LAMB for large-batch training. I think the comparison is not fair.","In data-parallel distributed training, increasing the batch size of the optimizer's updates is the most natural way to reduce wall-clock training time. Prevalent first-order stochastic methods such as SGD, provide a linear speed-up in the batch size, but only up to some critical batch size (c.f., [smooth convex optimization bounds](https://arxiv.org/abs/1106.4574), and [an empirical work suggesting the same](https://arxiv.org/abs/1811.03600)). This critical batch size is typically very different for different learning architectures and optimization algorithms, and it is often difficult to decouple the effect of, * the bias-variance terms in optimization,  * improper or insufficient hyper-parameter tuning, and  * implicit regularization of the optimizer for extremely over-parameterized learning problems.   As a result, many existing works that propose new optimization algorithms, miss important baselines or don't compare against them fairly. This paper highlights such an issue with the recently proposed layerwise normalization techniques [LARS](https://arxiv.org/abs/1811.03600) and [LAMB](https://arxiv.org/abs/1904.00962), which build upon the update rules for SGD w/ Polyak momentum and Adam respectively. These methods were proposed to speed up the large batch (pre-)training of Imagenet and BERT respectively, and have gained a lot of attention in benchmark competitions. This paper underlines that these techniques improve optimization either marginally or not at all when compared to their vanilla first-order counterparts. Moreover, it highlights nuances in their hyper-parameter choices which are very important to consider. Most importantly, it establishes simpler baselines for improving future optimization algorithms for the considered learning tasks.  ","This paper revisits the effectiveness of the optimizers designed for large-batch training such as LAMB and LARS by You et al. (2017, 2019) respectively. While it has been claimed and demonstrated (in perhaps limited settings though) that such optimizers can achieve better performance compared to other generic optimizers such as SGD or ADAM (in the sense that they don’t require a specific batch size), this paper re-evaluates these optimizers while fine-tuning all hyperparameters involved to potentially affect the result and finds that they do not work better as claimed; or, more precisely the standard optimization algorithms including Nesterov and Adam can match or outperform LARS as long as they are properly tuned. The paper provides empirical evidence obtained from Imagenet and BERT experiments to support their finding.","I carefully read the responses from the authors. However, the authors did not address my concern. I'd like to keep my score.  ###########################################################################################################  The authors used a huge amount of computing resources to tune hyperparameters of Adam/SGD and claimed that they can match the performance of LARS/LAMB for large-batch training. I think the comparison is not fair.","In this work, the authors compared the standard optimizers (i.e., Nesterov momentum, Adam) and optimizers with layer-wise normalization (i.e., LARS, LAMB) in training neural networks with large-batch sizes. Although LARS and LAMB were proposed and known as ""large-batch optimizers,"" the authors showed that the standard optimizers with careful hyperparameter tuning could match or exceed the state-of-the-art results by LARS (for training ResNet-50 on ImageNet, batch size = 32K) and LAMB (for pre-training BEAT, batch size = 65K) at large-batch settings within the same step budgets. The authors pointed out that the strong results depend on several optimization/regularization tricks, non-default values of uncommonly-tuned hyperparameters, and a careful learning rate schedule, but such details are not often discussed. With this point, the difficulties of comparing optimizers and the importance of rigorous empirical comparisons and open-sourcing in deep learning optimizer research are highlighted. ","The authors detail the significant effort required to reproduce results from the original LARS and LAMB papers.  Having reproduced results for LARS (for ResNet-50 training on ImageNet) and LAMB (for BERT pretraining), the authors then show that standard/older optimizers (Nesterov momentum and Adam) can match or even exceed LARS and LAMB at large batch sizes.  The authors provide in-depth details on both the difficulties required for them to reproduce the original results (i.e., fixing discrepancies between details in the publications and available source-code from online implementations) and their hyperparameter optimization for Nesterov Momentum and Adam on the datasets evaluated.  Also, insights and lessons are provided, both on the importance of hyperparameter tuning for comparison of DL solvers and on practitioners attempting to demonstrate performance gains for a new method (are not merely due to better tuning or regularization tricks).",0.14893617021276595,0.22340425531914893,0.24468085106382978,0.1276595744680851,0.24468085106382978,0.2553191489361702,0.2222222222222222,0.2,0.5111111111111111,0.2111111111111111,0.18888888888888888,0.10112359550561797,0.06367041198501873,0.10112359550561797,0.09363295880149813,0.09923664122137404,0.17557251908396945,0.16793893129770993,0.2833333333333333,0.2833333333333333,0.22875816993464052,0.15555555555555556,0.07865168539325842,0.17557251908396945,0.2,0.1503267973856209,0.16666666666666666,0.0749063670411985,0.13740458015267176,0.7666666666666667,0.12418300653594772,0.11805555555555555,0.20610687022900764,0.2833333333333333,0.17647058823529413,0.1736111111111111,0.21666666666666667,0.1503267973856209,0.1527777777777778,0.1111111111111111,0.11805555555555555,0.24305555555555555,0.15217391304347824,0.11634349030470913,0.20444444444444443,0.1558441558441558,0.1862348178137652,0.2016806722689075,0.11204481792717087,0.16289592760180996,0.6133333333333334,0.15637860082304525,0.14529914529914528,0.135678391959799,0.10397553516819573,0.1285714285714286,0.12165450121654502,0.13612565445026178,0.1619718309859155,0.16,0.1596244131455399,0.16666666666666666,0.23569023569023567
2,SP:ddc796b9185d372f4d0829f436bbca50c3990867,"This paper introduces a Jax package for implicitly differentiating various numerical solvers. Concretely, the authors develop a systemic methodology for producing gradients for a variety of optimization problems. Then, the authors prove that the Jacobian solution to the approximate numerical solution produces close enough gradients. Finally, the authors show the power of their framework on four test tasks.","The paper proposes a modular and efficient framework along with its JAX implementation for the implicit differentiation of optimization problems. The user defines the function F capturing the optimality conditions of the problem to be differentiated; then the framework combines implicit differentiation and autodiff of F to automatically differentiate the optimization problem. The proposed framework is labeled as efficient, since it doesn’t have to unroll the computational graph like in autodiff, and modular since it doesn’t require case-by-case mathematical derivation like in implicit differentiation. The authors show that existing implicit differentiation methods can be instantiated in their framework. They provide and empirically validate new bounds on the Jacobian error when the optimization problem is only solved approximately. The authors implemented four illustrative applications of their framework ( Hyperparameter Optimization Of Multiclass SVM; Dataset Distillation; Task-Driven Dictionary Learning; Sensitivity Analysis Of Molecular Dynamics). Code and implementation in JAX are provided along with the paper. ","This paper presents a module for implicit differentiation in JAX, which allows efficient differentiation through optimization and root-finding problems. The paper presents the general principle of combining the implicit function theorem with autodiff of optimality conditions, and discusses how this can work for a implicit functions such as a range of constrained optimization methods. Finally there are example applications to three machine learning tasks and one molecular dynamics simulation task where this framework improves on currently used methods.","The paper promises extension of Google’s JAX library by automatic and modular differentitation of implicitly defined functions. Given a solver $\theta\mapsto x^*(\theta)$ one asks for its Jacobian $\partial x^*(\theta)$. In cases when $x^*$ does not have an explicit form that can be automatically differentiated, the Jacobian can be computed from the optimality conditions $F$ having the general form $F(x^*(\theta),\theta)=0$. Jacobian $\partial x^*(\theta)$ is then given by a solution of a linear system involving $\partial_1 F$ and $\partial_2 F$. The authors describe a unified implementation in JAX and show the resulting simple interface for end-users. Various use cases are presented on examples and code-snippets figures, including stationary point conditions, KKT conditions, proximal gradient, projective gradient and mirror descent fixed point and more. On the theoretical side, the authors discuss the case when the optimization problem solution is only approximate and derive Jacobian error bounds under certain assumptions on optimality conditions $F$.","This paper provides a unified tool for combining the implicit differentiation technique and the  automatic differentiation method widely used in existing deep learning packages such as PyTorch and TensorFlow. The proposed implementation is easy to use for numeric optimization such as bilevel optimization, meta-learning and hyperparameter optimization because it covers many existing schemes such as fixed point, KKT point, projected method. In the experiments, the authors illustrate how their tool can be useful to simply the implementation. ","A good paper considers a critical problem, but contributions are somewhat weak.  This paper aims at a unified approach for implicit differentiation of optimization problems. The experiments results seem good, but the proposed methods lack novelty.","The authors propose a unified modular framework for implicit differentiation, which removes the need to manually derive the jacobians for each individual case by leveraging automatic differentiation of the optimality conditions. The proposed framework is shown to encompass various existing implicit differentiation schemes (such as stationary point- or KKT conditions) while also creating new ones (e.g. mirror descent fixed point). To handle the practical case in which the optimization problem can only be solved approximately, a theoretically justified bound on the error of the jacobian estimate is provided, showing that the error on the estimated jacobian is at most of the order of the deviation of the approximate solution from the optimal solution. Additionally, a JAX implementation of the proposed framework is described, with the promise of an open-source JAX library for implicit differentiation upon acceptance. Finally, four applications of the framework are demonstrated, highlighting its flexibility and ease of use.",0.3448275862068966,0.20689655172413793,0.25862068965517243,0.20689655172413793,0.15517241379310345,0.3103448275862069,0.1337579617834395,0.16560509554140126,0.14012738853503184,0.07643312101910828,0.2356687898089172,0.17721518987341772,0.189873417721519,0.13924050632911392,0.24050632911392406,0.11042944785276074,0.04294478527607362,0.1656441717791411,0.14102564102564102,0.32051282051282054,0.2777777777777778,0.12738853503184713,0.1518987341772152,0.09202453987730061,0.15384615384615385,0.25,0.11764705882352941,0.26582278481012656,0.15950920245398773,0.28205128205128205,0.3333333333333333,0.24183006535947713,0.08588957055214724,0.19230769230769232,0.3055555555555556,0.12418300653594772,0.23076923076923078,0.19444444444444445,0.17647058823529413,0.3055555555555556,0.16339869281045752,0.06535947712418301,0.186046511627907,0.17518248175182483,0.13574660633484165,0.17647058823529413,0.1914893617021277,0.17061611374407584,0.17796610169491525,0.1625,0.1872340425531915,0.12435233160621761,0.23870967741935487,0.11570247933884298,0.19108280254777074,0.19130434782608696,0.16379310344827588,0.14937759336099588,0.07035175879396985,0.1708860759493671,0.19298245614035087,0.21645021645021645,0.10582010582010583
3,SP:f202f3d6780876a0bdd7d7bd4d7047719a145177,"The authors propose a novel skill discovery method that combines standard mutual information maximization with notable changes. The first is that skill now enter a diffusion stage (random actions) before being predicted by a reverse predictor. The second is that environmental resets are exploited in order to construct a skill tree, wherein new skills are executed only after their parent skills. The final change is a pruning/growth strategy similar to VALOR, which is critical for constructing the skill tree.  The authors evaluate their method by comparing it to traditional skill discovery methods in terms of state coverage and performance on downstream tasks. ","This method learns a space of intrinsic goals to maximize coverage of the state space. This work utilizes mutual information between skills and states, where the entropy of states and negative entropy of states given options describe the diffusing and directing objectives respectively. This is done by learning skills with two separate parts, a long scale directed component and a short scale diffusing component. These skills have state distributions that differ by at least a specified factor. It then separates these skills along a hierarchical tree structure, where temporal abstraction occurs by calling lower level options, which have a limited range, controlling the shape of the tree by pruning skills with low difference, and adding new skills when all the skills satisfy the condition. ","The paper presents a framework for an unsupervised learning of robotic skills that balances directness of exploration and coverage of state space. The theory of the method builds on the notion of mutual information between states and skills, where the conditional entropy between states and skill definitions corresponds to the directed part of the learned policy, and entropy of the states to the diffusing part of the policy. The directed part is optimized to increase discriminability of the skills given the states using a discriminator network. The diffusing part performs a random walk policy with uniform distribution over actions.The paper further proposes to optimize the number of skills by requiring the minimum discriminability of skills and discarding skills that fall below the discriminability threshold. Finally, in order to be able to reach states that are farther away, the paper proposes to combine skills in a tree structure and gradually expand the tree by adding new skill nodes to the tree. The approach is shown to outperform other unsupervised skill discovery methods on such tasks as continuous maze, CartPole and Reacher in OpenAI Gym during both, unsupervised skill discovery phase and training of downstream tasks.","The paper proposes an unsupervised exploration method for reinforcement learning, called UPSIDE, that combines learning of directed skills that enable covering distant states, and a diffusive part that explores locally and helps expand the explored region further. The main contributions are both the topology of the policy (division to tree-structured skills and diffusive parts), a theory for training such policies, and a practical implementation that simplifies some of the technicalities induced by the theory. The experiments illustrate well the assumed benefits and include both toy tasks (a point mass in a maze) as well as more complex tasks such as HalfCheetah and Ant from OpenAI Gym. The experiments also compare to prior methods such as DIYAN and provide ablations of the importance of the different components. ","To increase the state space coverage with unsupervised skill discovery, the authors propose UPSIDE. They tackle reaching distant states (direct) and covering neighbor states (diffuse) at different stages. Also, they discover skills by forming a tree, which enables chaining of smaller skills to form far-reaching skills. Also, instead of fixing the number of skills to learn, they maximize the number of skills with a constraint on the output of the discriminator $q_\phi(z|s_{diff})$ and show that it is a lower bound of the mutual information objective. Empirical results on Maze and MuJoCo environments and further analyses are presented.","The paper proposes a novel algorithm for learning unsupervised skills based on empowerment. Specifically, direct-and-diffuse policies are proposed that first optimize empowerment and then after a fixed number of episode steps optimize action entropy. This yields policies that go to a certain point in a directed manner and then move around that point at random. Further, the UPSIDE algorithm is based on tracking the policies with high discriminability (i.e. low H(z|x)). The algorithm keeps a set of policies that are currently above a threshold and attempts to add new policies incrementally. Finally, each new policy can be assigned a parent policy, wherein the parent policy is executed to produce the starting state for the new policy. This allows the proposed algorithm to stack policies sequentially and reach goals further away. Empirically, the algorithm achieves good performance on pointmass, cheetah, walker, and ant tasks.","The idea of this work is to maximize coverage while ensuring learned skills are distinguishable. The learning framework is based on maximizing mutual information (MI) between latent random variables and states.  This paper proposes a decoupled objective for local coverage and directness, on top of it, a tree structure based exploration method is proposed to incrementally compose learned skills for maximum coverage.",0.1553398058252427,0.30097087378640774,0.17475728155339806,0.1553398058252427,0.2524271844660194,0.1262135922330097,0.29838709677419356,0.16129032258064516,0.16129032258064516,0.1532258064516129,0.14516129032258066,0.18461538461538463,0.14358974358974358,0.16923076923076924,0.09230769230769231,0.15748031496062992,0.2047244094488189,0.09448818897637795,0.17647058823529413,0.10784313725490197,0.0945945945945946,0.12903225806451613,0.15897435897435896,0.14173228346456693,0.1568627450980392,0.17567567567567569,0.20967741935483872,0.18974358974358974,0.15748031496062992,0.19607843137254902,0.12837837837837837,0.2903225806451613,0.28346456692913385,0.27450980392156865,0.22297297297297297,0.2903225806451613,0.19607843137254902,0.17567567567567569,0.1935483870967742,0.12162162162162163,0.1774193548387097,0.22580645161290322,0.1409691629955947,0.2080536912751678,0.15652173913043477,0.15609756097560976,0.20717131474103587,0.1575757575757576,0.23197492163009406,0.1593625498007968,0.17699115044247787,0.13970588235294118,0.1935483870967742,0.2236024844720497,0.18855218855218853,0.1924198250728863,0.14007782101167315,0.17467248908296942,0.18909090909090912,0.12698412698412698,0.14400000000000002,0.13414634146341464,0.13333333333333333
